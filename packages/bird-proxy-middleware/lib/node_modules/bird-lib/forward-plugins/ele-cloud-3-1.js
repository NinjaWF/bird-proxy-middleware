var express = require('express')
var fs = require('fs')
var url = require('url')
var path = require('path')
var request = require('request')
var colors = require('colors');
var cheerio = require('cheerio')

var birdUtils = require('bird-common/utils')

/**
 * 根据反馈全面完善 大象慧云 大B 登陆插件
 */

/**
 * get the normalized cookie from jar
 *
 * @param  {Array} cookieArray
 * @return {String} cookie string used in headers
 */
var redeemCookieFromJar = function (cookieArray) {
  var result = '';
  for (var i = 0; i < cookieArray.length; i++) {
    result += cookieArray[i].key + '=' + cookieArray[i].value + ';';
    if (i !== cookieArray.length - 1) {
      result += ' ';
    }
  }
  return result;
}

/**
 * 模拟整个登录的身份认证过程, 获取所需的cookie
 * @param serverInfo
 */
var mimicUUAPLogin = function (serverInfo) {
  
  //保证路径完整
  var TARGET_SERVER = getTargetServerUrl(serverInfo);
  
  if (!serverInfo.useUser) {
    birdUtils.logs(['error', '请设置好 SERVER_INFO.useUser'])
    return
  }
  
  var USERNAME = serverInfo.useUser;
  if (!serverInfo.users) {
    birdUtils.logs(['error', '请设置好 SERVER_INFO.users'])
    return
  }
  if (!(serverInfo.useUser in serverInfo.users)) {
    birdUtils.logs(['error', '请在 SERVER_INFO.users 中为 ' + serverInfo.useUser + ' 设置好密码'])
  }
  var PASSWORD = serverInfo.users[serverInfo.useUser];
  
  var cookieKey = getCookieKey(serverInfo)
  
  var jar = request.jar()
  
  loginAttempt[cookieKey] = true
  
  var loginEnded = function () {
    delete loginAttempt[cookieKey]
  }
  
  var tryUUAPLogin = function (body, accessResponse) {
    // 说明可以直接登陆 ???
    try {
      // use cheerio to parse dom
      var $ = cheerio.load(body);
    } catch (ex) {
      birdUtils.log('error', 'Failed to parsed the login page html. Please check...')
      birdUtils.log('debug', body)
      loginEnded()
      return;
    }
    
    // 得到 uuap login form 的一些信息
    var pathname = '/itax-sso/doLogin';
    var username = USERNAME;
    var password = PASSWORD;
    
    var SSO_LOGIN_URL = accessResponse.request.uri.protocol + '//' + accessResponse.request.uri.host + pathname;
    
    // 模拟 login 登陆
    request.post({
      url: SSO_LOGIN_URL,
      json: {
        dxhyu: Buffer.from(username).toString('base64'),
        dxhyp: Buffer.from(password).toString('base64'),
        // redirect_url: TARGET_SERVER,
      },
      jar: jar
    }, function (error, _res, body) {
      if (error) {
        birdUtils.logs(
          ['error', '尝试登陆时, 检测到错误'],
          ['error', error],
          ['error', body],
          [])
        loginEnded()
        return
      }
      // 判断是否登陆账户错误
      if (body.code == 500) {
        birdUtils.logs(['error', '登陆信息有误, 请检查用户名和账号密码是否正确'],
          ['error', body],
          [])
        loginEnded()
        return
      } else {
        // 登录成功后，会在login域种下cookie，并携带ticket重定向
        var presentCookie = jar.getCookieString(SSO_LOGIN_URL);
        if (!presentCookie) {
          birdUtils.logs(
            ['error', '登陆后没有获取到cookie, 检测到错误'],
            ['error', error],
            ['error', body],
            [])
          loginEnded()
          return
        }
        
        // 目前大b单点很low逼，并不是携带ticket重定向，
        // 那这里直接把cookie, set in TARGET_SERVER
        jar.setCookie(presentCookie, TARGET_SERVER);
        
        request.post({
          url: TARGET_SERVER,
          jar: jar
        }, function (error, redirectResponse, redirectBody) {
          if (error) {
            birdUtils.logs(
              ['error', '登陆后token转发时, 检测到错误'],
              ['error', error],
              ['error', body],
              [])
            loginEnded()
            return
          }
          
          var cookieKey = getCookieKey(serverInfo)
          cookies[cookieKey] = jar
          birdUtils.logs(
            ['info', '登陆步骤完成, 请检查 cookie 记录是否正确'],
            ['info', ' ====================== COOKIE ======================= '],
            ['info', jar.getCookieString(TARGET_SERVER)],
            ['info', ' ===================================================== '],
            [])
          loginEnded()
        })
      }
    })
  }
  
  /**
   *  正常情况下，应使用post方式会返回302；
   *  这里直接使用get，请求接收到302后，直接进入302的地址
   */
  request({
    url: TARGET_SERVER,
    jar: jar
  }, function (error, response, body) {
    if (error) {
      birdUtils.logs(
        ['error', '初次访问开发服务器时, 检测到错误'],
        ['error', error],
        ['error', body],
        [])
      loginEnded()
      return
    }
    
    /**
     * 尝试连接使用uuap的服务之后, 目前有一种情况:
     *
     * - get方式会直接发起 302 , 直接会重定向到目标 uuap login page
     *
     * - 注意, 有可能还会有其他的登陆可能
     *
     */
    if (new RegExp(TARGET_SERVER).exec(response.request.href) && body) {
      tryUUAPLogin(body, response)
      return
    }
    
    loginEnded()
    birdUtils.logs(
      ['error', '无法自动检测登陆的方法, 请确保服务器的url是否正确, 看服务器访问的结果是否正确'],
      ['error', body],
      ['error', '注意!!! url可能应该要包含 context path 如 http://172.12.34.56:8080/p2p 里的 /p2p'],
      ['error', '如果无法自动检测出登陆的初始页面, 你可以根据返回的页面, 推断并设置 SERVER_INFO.loginUrl 来主动指定.'],
      []
    )
  })
}

var getCookieKey = function (serverInfo) {
  return serverInfo.server + '|' + serverInfo.useUser
}

var getTargetServerUrl = function (serverInfo) {
  return serverInfo.server.slice('-1') === '/' ? serverInfo.server : serverInfo.server + '/'
}

/**
 * cookie string 的缓存
 *
 * @type {{}}
 *  $KEY : cookie string
 *
 *  $KEY = $server + '|' + $uuap_server + '|' + $username
 *
 *  见 getCookieKey
 */
var cookies = {}

/**
 * 用于避免重复产生login的动作, 相同时间段里, 我们只需要做一次login尝试即可
 * @type {{}}
 *  $KEY : 见 cookies 的 $KEY 解释
 */
var loginAttempt = {}

/**
 * 登录方式
 *
 * @param isRetry
 * @param serverInfo
 * @param urlOptions
 * @returns {boolean} 是否在尝试登陆
 */
module.exports = function (isRetry, serverInfo, urlOptions) {
  // 先尝试在我们的历史cookies里找找看有没有可用的cookie
  var cookieKey = getCookieKey(serverInfo)
  var cookie = cookies[cookieKey]
  
  if (!cookie || isRetry) {
    // 如果进入 retry, 则干脆把所有cookie都清除
    if (isRetry) {
      loginAttempt = {}
      cookies = {}
    }
    
    if (!loginAttempt[cookieKey]) {
      // 如果没有可用的cookie, 或者我们发现需要重新登录, 则重新走一遍 login 的流程获取cookie
      mimicUUAPLogin(serverInfo)
      return true
    }
  } else {
    // 我们现在需要通过 targetUrl 来获取cookie, 而不是简单的去获取 root 下的cookie
    // 因为, cookie 根据path不一样是有不一样的效果的
    var targetUrl = getTargetServerUrl(serverInfo) + (urlOptions.path || '').replace(/^\//, '')
    
    // 否则, 尝试把cookie写到header中, 供转发流程使用
    var cookieForUrl = cookie.getCookieString(targetUrl);
    
    urlOptions.headers.cookie = (cookieForUrl ? cookieForUrl + ';' : '')
      + urlOptions.headers.cookie;
    // console.log('@debug, urloptions in uuap', targetUrl, urlOptions)
  }
  return false
}
