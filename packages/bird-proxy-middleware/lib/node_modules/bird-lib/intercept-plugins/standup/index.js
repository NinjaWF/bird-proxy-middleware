var concat = require('concat-stream')
var nps = require('path');
var ruleMatched = require('./lib/rule-matched');
var Storage = require('./lib/storage');
var utils = require('../../../common/utils');

var storageCollection = {};

var default_opt = {
    matcher: function (url) {
        return url !== '/favicon.ico';
    },
    checkIsBroken: function (res, req) {
        return parseInt(res.statusCode, 10) >= 400;
    },
    saveLastCache: true,
    key: ''
};

var saveLastCache = default_opt.saveLastCache;

process.on('SIGINT', function () {
    if (saveLastCache) {
        utils.logs(['info:' + 'standup bye!']);
        for (var key in storageCollection) {
            utils.logs(['info:' + 'cache saved in ' + storageCollection[key].path]);
            storageCollection[key].saveSync()
        }
    }
    process.exit();
});

function getCachePathByKey(key) {
    return nps.join(__dirname, 'lib/storage', key + 'cache.json');
}

/**
 * @def:
 * ///
 *  缓存最新一次的转发 响应。
 *  当检测到服务器错误，就返回上一次最新的 cache
 * ///
 *      opts: {}                    // 参考 `default_opt`
 *      clientReq: IncomingMessage // 客户端请求
 *      localReq: ClientRequest    // 本地转发给远端的请求
 *      localRes: ServerResponse   // 本地返回给客户端的响应
 *      remoteRes: IncomingMessage // 本地返回给客户端的响应
 */
function standUp(opts, clientReq, localReq, localRes, remoteRes) {
    opts = Object.assign({}, default_opt, opts);
    saveLastCache = opts.saveLastCache;
    if (saveLastCache === 'false') {
        saveLastCache = false;
    }
    var checkIsBroken = opts.checkIsBroken;
    var path = opts.path;
    var matcher = opts.matcher;
    var key = opts.key;

    var storage = storageCollection[key]
                = storageCollection[key] || new Storage();
    var url = clientReq.url;

    storage.path = path && nps.resolve(path) || getCachePathByKey(key);
    storage.isEmpty() && storage.loadSync();

    if (ruleMatched(matcher, url)) {
        if (checkIsBroken(remoteRes, clientReq)) {
            if (storage.exists(url)) {
                utils.logs(['info:' + url + ': standup 拦截器正在发功！']);

                var cache = storage.get(url);
                localRes.writeHead(
                    cache.statusCode, cache.statusMessage,
                    Object.assign({
                        'X-BirdV3-intercept': 'StandUp'
                    }, cache.headers)
                );
                localRes.write(cache.body);
                localRes.addTrailers(cache.trailers);
                localRes.end();
                return true;
            }
            // return true;
        }
        else {
            utils.logs(['info:' + url + ': standup 正在缓存远程服务器响应']);
            // remoteRes
            remoteRes.pipe(concat(function getBody(body) {
                storage.set(url, {
                    statusCode: remoteRes.statusCode,
                    statusMessage: remoteRes.statusMessage,
                    headers: remoteRes.headers,
                    trailers: remoteRes.trailers,
                    body: body
                });
            }));
        }
    }
}


module.exports = function (opts) {
    return standUp.bind(null, opts);
};